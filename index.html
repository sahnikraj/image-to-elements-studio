<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="google-site-verification" content="CYKIt9rg968bFwUGDEvBt8A8b9lb85KJkORHajVsoJg" />
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FL7CQ5SXS1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag("js", new Date());
    gtag("config", "G-FL7CQ5SXS1");
  </script>
  <title>MS Paint Online - Free MS Paint Online Tool with Additional Features</title>
  <meta name="description" content="Use MS Paint Online for free in your browser. A beginner-friendly paint online tool with classic drawing tools, selection, shapes, text, spray, color picker, zoom, and save options." />
  <meta name="robots" content="index,follow,max-image-preview:large,max-snippet:-1,max-video-preview:-1" />
  <meta name="keywords" content="paint, ms paint, js paint, jspaint, mspaint, paint javascript, paint online, online paint, paint.js, ms paint online, paint web, paint app online, online paint tool, free paint online, microsoft paint online, online microsoft paint, online ms paint, js paint online, mspaint online, paint online free, jspaint app, paint website, paint program, paint browser, windows paint, paintjs, jspaitn, jspait, mspaitn, psint, painr, paimt, paint onlune, paint onoine, mspainy, oaint, pai nt" />
  <meta name="theme-color" content="#c0c0c0" />
  <link rel="canonical" href="https://mspaint.online/" />
  <link rel="alternate" hreflang="x-default" href="https://mspaint.online/" />
  <link rel="alternate" hreflang="en" href="https://mspaint.online/" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://mspaint.online/" />
  <meta property="og:title" content="MS Paint Online - Free MS Paint Online Tool with Additional Features" />
  <meta property="og:description" content="Free online MS Paint alternative in your browser with classic tools, beginner-friendly controls, and no install needed." />
  <meta property="og:site_name" content="MSPaint.Online" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="MS Paint Online - Free MS Paint Online Tool with Additional Features" />
  <meta name="twitter:description" content="Draw, edit, and save instantly with a free MS Paint online tool." />
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "MS Paint Online",
      "alternateName": ["JS Paint", "JSPaint", "MSPaint"],
      "applicationCategory": "GraphicsApplication",
      "operatingSystem": "Any",
      "url": "https://mspaint.online/",
      "description": "Free MS Paint online tool with classic paint controls and extra features for browser-based drawing and editing.",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "inLanguage": "en",
      "isAccessibleForFree": true
    }
  </script>
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "FAQPage",
      "mainEntity": [
        {
          "@type": "Question",
          "name": "What is MS Paint Online?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "MS Paint Online is a free browser paint app that works like classic Microsoft Paint, so you can draw, erase, add shapes, and save without installing software."
          }
        },
        {
          "@type": "Question",
          "name": "Is this paint online tool free to use?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes. This online paint tool is free and designed for quick sketches, simple image edits, and beginner-friendly drawing."
          }
        },
        {
          "@type": "Question",
          "name": "Does this work as an MS Paint alternative?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes. If you are looking for an MS Paint alternative, this tool includes familiar paint controls such as selection, brush, spray, fill, text, and shapes."
          }
        },
        {
          "@type": "Question",
          "name": "Can I use it as JS Paint or JSPaint in browser?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes. Users searching for JS Paint, JSPaint, paint.js, or paint javascript can use this browser paint app as a simple online replacement."
          }
        },
        {
          "@type": "Question",
          "name": "Do I need to install Microsoft Paint?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "No install is required. Open the website and start drawing directly in your browser."
          }
        },
        {
          "@type": "Question",
          "name": "Can beginners use this paint app online easily?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes. The interface is made for beginners with clear tools and familiar paint behavior."
          }
        },
        {
          "@type": "Question",
          "name": "Does online MS Paint support spray, brush, and pencil tools?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes. You can use spray, brush, and pencil tools, and adjust controls for different drawing styles."
          }
        },
        {
          "@type": "Question",
          "name": "Can I add text and shapes in this paint website?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes. The tool supports text, line, curve, polygon, rectangle, rounded rectangle, and ellipse shapes."
          }
        },
        {
          "@type": "Question",
          "name": "Can I save my drawing from this paint browser app?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes. You can save your work to your device in common image formats."
          }
        },
        {
          "@type": "Question",
          "name": "Is this useful for quick edits and simple design tasks?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes. It is useful for quick edits, annotations, simple shapes, and basic visual drafts."
          }
        },
        {
          "@type": "Question",
          "name": "Does this online paint program work on modern browsers?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes. It is designed to run in modern browsers on desktop systems."
          }
        },
        {
          "@type": "Question",
          "name": "Can I use this as a classic paint style tool?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes. The layout follows a classic paint style so users familiar with older paint tools can work comfortably."
          }
        },
        {
          "@type": "Question",
          "name": "What if I searched typo keywords like jspaitn or mspaitn?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "If you searched typo variants such as jspaitn, jspait, mspaitn, paimt, or painr, you are still in the right place for a free online paint tool."
          }
        },
        {
          "@type": "Question",
          "name": "Is this Microsoft Paint online for free?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes. This is a free Microsoft Paint online style application for browser-based drawing."
          }
        },
        {
          "@type": "Question",
          "name": "Can I use this as a paint app without login?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes. You can start drawing without signup requirements."
          }
        }
      ]
    }
  </script>
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "HowTo",
      "name": "How to use MS Paint Online",
      "description": "Beginner steps to draw and save using MS Paint Online.",
      "totalTime": "PT2M",
      "step": [
        {
          "@type": "HowToStep",
          "name": "Open the paint tool",
          "text": "Open https://mspaint.online/ in your browser."
        },
        {
          "@type": "HowToStep",
          "name": "Choose a drawing tool",
          "text": "Select pencil, brush, spray, fill, shapes, or text from the left toolbar."
        },
        {
          "@type": "HowToStep",
          "name": "Draw or edit",
          "text": "Use color palette, size controls, and selection tools to create or edit your image."
        },
        {
          "@type": "HowToStep",
          "name": "Adjust view and tools",
          "text": "Use zoom and shape options for better control."
        },
        {
          "@type": "HowToStep",
          "name": "Save your file",
          "text": "Use Save options to download your drawing."
        }
      ]
    }
  </script>
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Organization",
      "name": "MSPaint.Online",
      "url": "https://mspaint.online/",
      "description": "Free MS Paint online tool with additional features for browser-based drawing."
    }
  </script>
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      "itemListElement": [
        {
          "@type": "ListItem",
          "position": 1,
          "name": "Home",
          "item": "https://mspaint.online/"
        }
      ]
    }
  </script>
  <style>
    :root {
      --ui-bg: #c0c0c0;
      --panel: #d4d0c8;
      --shadow-dark: #404040;
      --shadow-mid: #808080;
      --shadow-light: #ffffff;
      --selected: #1341d4;
      --canvas-bg: #ffffff;
      --text: #141414;
      --status: #ededed;
    }

    * {
      box-sizing: border-box;
      font-family: Tahoma, "MS Sans Serif", sans-serif;
    }

    html,
    body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: var(--ui-bg);
      color: var(--text);
      user-select: none;
    }

    .window {
      height: 100%;
      display: grid;
      grid-template-rows: auto 1fr auto auto;
      border-top: 2px solid var(--shadow-light);
      border-left: 2px solid var(--shadow-light);
      border-right: 2px solid var(--shadow-dark);
      border-bottom: 2px solid var(--shadow-dark);
      background: var(--panel);
    }

    .menu-bar {
      display: flex;
      gap: 10px;
      align-items: center;
      font-size: 12px;
      padding: 2px 6px;
      border-bottom: 1px solid #9b9b9b;
      position: relative;
    }

    .menu-spacer {
      margin-left: auto;
    }

    .header-links {
      display: inline-flex;
      gap: 12px;
      align-items: center;
      font-weight: 600;
    }

    .header-links a {
      color: #1b326f;
      text-decoration: none;
      border-bottom: 1px solid transparent;
      padding-bottom: 1px;
    }

    .header-links a:hover {
      border-bottom-color: #1b326f;
    }

    .header-meta {
      font-weight: 700;
      color: #1b326f;
      white-space: nowrap;
    }

    .menu-item {
      position: relative;
      padding: 2px 3px;
      cursor: default;
    }

    .menu-item:hover,
    .menu-item.open {
      background: var(--selected);
      color: white;
    }

    .dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      min-width: 190px;
      background: var(--panel);
      border-top: 1px solid var(--shadow-light);
      border-left: 1px solid var(--shadow-light);
      border-right: 1px solid var(--shadow-dark);
      border-bottom: 1px solid var(--shadow-dark);
      box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.25);
      display: none;
      z-index: 1000;
      color: #111;
    }

    .menu-item.open .dropdown {
      display: block;
    }

    .drop-btn {
      width: 100%;
      border: 0;
      background: transparent;
      text-align: left;
      font-size: 12px;
      padding: 4px 9px;
      cursor: pointer;
      color: inherit;
      display: flex;
      justify-content: space-between;
      gap: 10px;
    }

    .drop-btn:hover {
      background: var(--selected);
      color: white;
    }

    .drop-sep {
      height: 1px;
      background: #9f9f9f;
      margin: 2px 5px;
    }

    .top-strip {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 11px;
      padding: 4px 6px;
      border-bottom: 1px solid #9a9a9a;
    }

    .bevel-input,
    .bevel-select,
    .bevel-btn {
      border-top: 1px solid var(--shadow-dark);
      border-left: 1px solid var(--shadow-dark);
      border-right: 1px solid var(--shadow-light);
      border-bottom: 1px solid var(--shadow-light);
      background: white;
      font-size: 11px;
      padding: 2px 4px;
      min-height: 22px;
    }

    .bevel-btn {
      background: var(--panel);
      cursor: pointer;
    }

    .bevel-btn:active {
      border-top-color: var(--shadow-light);
      border-left-color: var(--shadow-light);
      border-right-color: var(--shadow-dark);
      border-bottom-color: var(--shadow-dark);
    }

    .workspace {
      min-height: 0;
      display: grid;
      grid-template-columns: 92px 1fr;
    }

    .toolbar {
      border-right: 1px solid #8f8f8f;
      padding: 6px 4px 10px;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .tool-grid {
      display: grid;
      grid-template-columns: repeat(2, 28px);
      gap: 4px;
      margin-bottom: 8px;
      width: 60px;
    }

    .tool {
      height: 28px;
      width: 28px;
      display: grid;
      place-items: center;
      font-size: 15px;
      line-height: 1;
      background: var(--panel);
      border-top: 1px solid var(--shadow-light);
      border-left: 1px solid var(--shadow-light);
      border-right: 1px solid var(--shadow-dark);
      border-bottom: 1px solid var(--shadow-dark);
      cursor: pointer;
      padding: 0;
    }

    .tool.tool-label {
      font-size: 9px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    .tool-icon {
      width: 16px;
      height: 16px;
      display: block;
      background-repeat: no-repeat;
      background-position: center;
      background-size: 16px 16px;
      image-rendering: pixelated;
      pointer-events: none;
    }

    .tool-icon.fallback {
      font-size: 12px;
      font-weight: 700;
      line-height: 18px;
      text-align: center;
    }

    .tool.active {
      border-top: 1px solid var(--shadow-dark);
      border-left: 1px solid var(--shadow-dark);
      border-right: 1px solid var(--shadow-light);
      border-bottom: 1px solid var(--shadow-light);
      background: #bbb8b0;
      outline: 1px dotted #000;
      outline-offset: -4px;
    }

    .tool-config {
      display: grid;
      gap: 7px;
      font-size: 10px;
      width: 60px;
    }

    .tool-config label {
      display: grid;
      gap: 2px;
      white-space: normal;
      line-height: 1.2;
      word-break: break-word;
    }

    .tool-config input[type="range"] {
      width: 60px;
      min-width: 60px;
    }

    .canvas-shell {
      min-height: 0;
      overflow: auto;
      background: #b0b0b0;
      border-top: 1px solid var(--shadow-dark);
      border-left: 1px solid var(--shadow-dark);
      border-right: 1px solid var(--shadow-light);
      border-bottom: 1px solid var(--shadow-light);
      padding: 1px;
    }

    .canvas-stage {
      position: relative;
      width: max-content;
      min-width: 100%;
      min-height: 100%;
      background: #8f8f8f;
      padding: 2px;
    }

    .canvas-holder {
      width: 1200px;
      height: 700px;
      position: relative;
      background: white;
      border-top: 1px solid var(--shadow-light);
      border-left: 1px solid var(--shadow-light);
      border-right: 1px solid var(--shadow-dark);
      border-bottom: 1px solid var(--shadow-dark);
      transform-origin: top left;
      image-rendering: pixelated;
      cursor: crosshair;
      touch-action: none;
    }

    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      touch-action: none;
    }

    .selection {
      position: absolute;
      border: 1px dashed #1f4dff;
      display: none;
      pointer-events: auto;
      cursor: move;
      background: transparent;
      z-index: 20;
      touch-action: none;
    }

    .text-editor {
      position: absolute;
      min-width: 80px;
      min-height: 24px;
      resize: both;
      overflow: auto;
      border: 1px dashed #1f4dff;
      background: rgba(255, 255, 255, 0.95);
      color: #000;
      padding: 2px 3px;
      outline: none;
      z-index: 30;
      font-family: Tahoma, "MS Sans Serif", sans-serif;
      white-space: pre;
      user-select: text;
      -webkit-user-select: text;
    }

    .selection.dragging {
      opacity: 0.85;
    }

    .palette-row {
      display: grid;
      grid-template-columns: 76px 1fr;
      align-items: center;
      gap: 8px;
      border-top: 1px solid #999;
      padding: 4px 8px;
      background: var(--panel);
    }

    .swatches {
      width: 64px;
      height: 34px;
      position: relative;
    }

    .swatch {
      width: 28px;
      height: 28px;
      position: absolute;
      border-top: 1px solid var(--shadow-light);
      border-left: 1px solid var(--shadow-light);
      border-right: 1px solid var(--shadow-dark);
      border-bottom: 1px solid var(--shadow-dark);
    }

    #bgSwatch { left: 25px; top: 6px; }
    #fgSwatch { left: 7px; top: 0; z-index: 2; }

    .palette {
      display: grid;
      grid-template-columns: repeat(28, minmax(14px, 1fr));
      gap: 2px;
    }

    .color {
      height: 18px;
      border-top: 1px solid var(--shadow-light);
      border-left: 1px solid var(--shadow-light);
      border-right: 1px solid var(--shadow-dark);
      border-bottom: 1px solid var(--shadow-dark);
      cursor: pointer;
      padding: 0;
    }

    .status {
      border-top: 1px solid #959595;
      background: var(--status);
      padding: 3px 8px;
      font-size: 11px;
      display: flex;
      justify-content: space-between;
      gap: 8px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .hidden { display: none; }

    @media (max-width: 1024px) {
      .workspace { grid-template-columns: 88px 1fr; }
      .tool-grid { grid-template-columns: repeat(2, 28px); }
      .palette { grid-template-columns: repeat(14, minmax(14px, 1fr)); }
      .tool-config { font-size: 10px; }
      .header-links { gap: 8px; font-size: 11px; }
      .header-meta { font-size: 11px; }
    }
  </style>
</head>
<body>
  <div class="window">
    <div class="menu-bar" id="menuBar">
      <div class="menu-item" data-menu="file">File
        <div class="dropdown">
          <button class="drop-btn" data-action="new">New <span>Ctrl+N</span></button>
          <button class="drop-btn" data-action="open">Open <span>Ctrl+O</span></button>
          <button class="drop-btn" data-action="save-png">Save as PNG <span>Ctrl+S</span></button>
          <button class="drop-btn" data-action="save-jpg">Save as JPG <span></span></button>
          <div class="drop-sep"></div>
          <button class="drop-btn" data-action="paste-image">Paste Image <span>Ctrl+V</span></button>
        </div>
      </div>

      <div class="menu-item" data-menu="edit">Edit
        <div class="dropdown">
          <button class="drop-btn" data-action="undo">Undo <span>Ctrl+Z</span></button>
          <button class="drop-btn" data-action="redo">Redo <span>Ctrl+Y</span></button>
          <div class="drop-sep"></div>
          <button class="drop-btn" data-action="copy-selection">Copy Selection <span>Ctrl+C</span></button>
          <button class="drop-btn" data-action="cut-selection">Cut Selection <span>Ctrl+X</span></button>
          <button class="drop-btn" data-action="paste-selection">Paste Selection <span>Ctrl+V</span></button>
          <button class="drop-btn" data-action="delete-selection">Delete Selection <span>Del</span></button>
        </div>
      </div>

      <div class="menu-item" data-menu="view">View
        <div class="dropdown">
          <button class="drop-btn" data-action="zoom-in">Zoom In <span>+</span></button>
          <button class="drop-btn" data-action="zoom-out">Zoom Out <span>-</span></button>
          <button class="drop-btn" data-action="zoom-reset">Actual Size <span>1</span></button>
          <button class="drop-btn" data-action="toggle-grid">Toggle Pixel Grid <span>G</span></button>
        </div>
      </div>

      <div class="menu-item" data-menu="image">Image
        <div class="dropdown">
          <button class="drop-btn" data-action="crop-selection">Crop to Selection <span>Ctrl+Shift+X</span></button>
          <button class="drop-btn" data-action="resize-canvas">Resize Canvas <span></span></button>
          <button class="drop-btn" data-action="resize-skew">Resize / Skew <span></span></button>
          <button class="drop-btn" data-action="flip-horizontal">Flip Horizontal <span></span></button>
          <button class="drop-btn" data-action="flip-vertical">Flip Vertical <span></span></button>
          <button class="drop-btn" data-action="rotate-left">Rotate 90° Left <span></span></button>
          <button class="drop-btn" data-action="rotate-right">Rotate 90° Right <span></span></button>
          <button class="drop-btn" data-action="rotate-180">Rotate 180° <span></span></button>
          <div class="drop-sep"></div>
          <button class="drop-btn" data-action="clear">Clear Image <span></span></button>
        </div>
      </div>

      <div class="menu-item" data-menu="colors">Colors
        <div class="dropdown">
          <button class="drop-btn" data-action="swap-colors">Swap FG/BG <span>X</span></button>
          <button class="drop-btn" data-action="pick-custom">Custom Color <span></span></button>
          <button class="drop-btn" data-action="invert-colors">Invert Colors <span></span></button>
          <button class="drop-btn" data-action="grayscale">Grayscale <span></span></button>
        </div>
      </div>

      <div class="menu-item" data-menu="help">Help
        <div class="dropdown">
          <button class="drop-btn" data-action="about">About <span></span></button>
          <button class="drop-btn" data-action="tips">Pro Tips <span></span></button>
        </div>
      </div>

      <span class="menu-spacer"></span>
      <nav class="header-links" aria-label="Site pages">
        <a href="/what-it-is.html">What It Is</a>
        <a href="/key-features.html">Key Features</a>
        <a href="/use-cases.html">Use Cases</a>
        <a href="/faq.html">FAQ</a>
      </nav>
      <span id="titleMeta" class="header-meta">Untitled - 1200x700</span>

      <input class="hidden" id="fileInput" type="file" accept="image/*" />
      <input class="hidden" id="customColor" type="color" value="#000000" />
    </div>

    <div class="top-strip">
      <label>Size <input class="bevel-input" id="size" type="range" min="1" max="72" value="2" /></label>
      <label>Font <select class="bevel-select" id="fontSize"><option>12</option><option selected>16</option><option>24</option><option>32</option><option>48</option><option>64</option></select></label>
      <label>Zoom <select class="bevel-select" id="zoom"><option value="0.5">50%</option><option value="1" selected>100%</option><option value="2">200%</option><option value="4">400%</option><option value="8">800%</option></select></label>
      <label>Shape <select class="bevel-select" id="shapeMode"><option value="stroke">Outline</option><option value="fill">Fill</option><option value="both">Fill + Outline</option></select></label>
      <label>Tolerance <input class="bevel-input" id="fillTolerance" type="range" min="0" max="120" value="32" /></label>
      <button class="bevel-btn" id="btnSnapshot">Snapshot</button>
    </div>

    <div class="workspace">
      <aside class="toolbar">
        <div class="tool-grid" id="toolGrid"></div>
        <div class="tool-config">
          <label>Density <span id="sprayDensityValue">35</span><input class="bevel-input" id="sprayDensity" type="range" min="0" max="100" value="35" /></label>
          <label>Radius <span id="sprayRadiusValue">25</span><input class="bevel-input" id="sprayRadius" type="range" min="0" max="100" value="25" /></label>
          <label><input id="transparentSelection" type="checkbox" /> Transparent selection</label>
        </div>
      </aside>

      <section class="canvas-shell">
        <div class="canvas-stage" id="stage">
          <div class="canvas-holder" id="holder">
            <canvas id="paintCanvas" width="1200" height="700"></canvas>
            <canvas id="previewCanvas" width="1200" height="700"></canvas>
            <div class="selection" id="selection"></div>
            <textarea id="textEditor" class="text-editor hidden" spellcheck="false"></textarea>
          </div>
        </div>
      </section>
    </div>

    <div class="palette-row">
      <div class="swatches">
        <div class="swatch" id="bgSwatch"></div>
        <div class="swatch" id="fgSwatch"></div>
      </div>
      <div class="palette" id="palette"></div>
    </div>

    <div class="status">
      <span id="statusLeft">Ready</span>
      <span id="statusRight">x:0 y:0</span>
    </div>
  </div>

  <script>
    const TOOL_ICON = {
      select: 'assets/tool-icons/select.svg',
      freeselect: 'assets/tool-icons/lasso-polygon.svg',
      pencil: 'assets/tool-icons/pencil.svg',
      brush: 'assets/tool-icons/brush.svg',
      airbrush: 'assets/tool-icons/spray.svg',
      eraser: 'assets/tool-icons/eraser.svg',
      line: 'assets/tool-icons/line.svg',
      curve: 'assets/tool-icons/scribble.svg',
      polygon: 'assets/tool-icons/polygon.svg',
      rect: 'assets/tool-icons/rectangle.svg',
      ellipse: 'assets/tool-icons/circle.svg',
      roundrect: 'assets/tool-icons/rectangle-rounded-top.svg',
      fill: 'assets/tool-icons/bucket.svg',
      text: 'assets/tool-icons/letter-t.svg',
      eyedropper: 'assets/tool-icons/color-picker.svg',
      magnifier: 'assets/tool-icons/zoom-in.svg'
    };

    const TOOLS = [
      { id: 'select', icon: TOOL_ICON.select, title: 'Select' },
      { id: 'freeselect', icon: TOOL_ICON.freeselect, title: 'Free-form Select' },
      { id: 'pencil', icon: TOOL_ICON.pencil, title: 'Pencil' },
      { id: 'brush', icon: TOOL_ICON.brush, title: 'Paint Brush' },
      { id: 'airbrush', icon: TOOL_ICON.airbrush, title: 'Spray' },
      { id: 'eraser', icon: TOOL_ICON.eraser, title: 'Eraser' },
      { id: 'line', icon: TOOL_ICON.line, title: 'Line' },
      { id: 'curve', icon: TOOL_ICON.curve, title: 'Curve' },
      { id: 'polygon', icon: TOOL_ICON.polygon, title: 'Polygon' },
      { id: 'rect', icon: TOOL_ICON.rect, title: 'Rectangle' },
      { id: 'ellipse', icon: TOOL_ICON.ellipse, title: 'Ellipse' },
      { id: 'roundrect', icon: TOOL_ICON.roundrect, title: 'Rounded Rectangle' },
      { id: 'fill', icon: TOOL_ICON.fill, title: 'Fill Bucket' },
      { id: 'text', icon: TOOL_ICON.text, title: 'Text' },
      { id: 'eyedropper', icon: TOOL_ICON.eyedropper, title: 'Eyedropper' },
      { id: 'magnifier', icon: TOOL_ICON.magnifier, title: 'Magnifier' }
    ];

    const COLORS = [
      '#000000','#7f7f7f','#7f0000','#7f7f00','#007f00','#007f7f','#00007f','#7f007f',
      '#3f3f3f','#bfbfbf','#ff0000','#ffff00','#00ff00','#00ffff','#0000ff','#ff00ff',
      '#ffffff','#c0c0c0','#804000','#ff8040','#408000','#00a0ff','#8040ff','#ff40a0',
      '#ff8080','#80ff80','#8080ff','#ffd27f','#404000','#004040','#400040','#000040',
      '#4040ff','#40ff40','#ff4040','#40ffff','#ff40ff','#ffff40','#8b4513','#1e90ff',
      '#adff2f','#ff1493','#a0522d','#2f4f4f','#f5deb3','#00ced1','#8a2be2','#dc143c',
      '#2e8b57','#c71585','#ff8c00','#00bfff','#8fbc8f','#483d8b','#b8860b','#cd5c5c'
    ];

    const canvas = document.getElementById('paintCanvas');
    const preview = document.getElementById('previewCanvas');
    const holder = document.getElementById('holder');
    const stage = document.getElementById('stage');
    const selectionEl = document.getElementById('selection');
    const textEditorEl = document.getElementById('textEditor');

    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const pctx = preview.getContext('2d', { willReadFrequently: true });
    const STORAGE_KEY = 'web-paint-studio.session.v1';

    const state = {
      tool: 'pencil',
      drawing: false,
      pointerId: null,
      startX: 0,
      startY: 0,
      lastX: 0,
      lastY: 0,
      fg: '#000000',
      bg: '#ffffff',
      size: 2,
      fontSize: 16,
      zoom: 1,
      shapeMode: 'stroke',
      fillTolerance: 32,
      sprayDensity: 35,
      sprayRadius: 25,
      pixelGrid: false,
      history: [],
      future: [],
      maxHistory: 70,
      fileName: 'Untitled',
      selection: null,
      clipboardImage: null,
      selectionDrag: null,
      transparentSelection: false,
      curveDraft: null,
      freeSelectPath: null,
      textEditor: null,
      sprayTimer: null
    };
    let persistTimer = null;

    const els = {
      toolGrid: document.getElementById('toolGrid'),
      palette: document.getElementById('palette'),
      fgSwatch: document.getElementById('fgSwatch'),
      bgSwatch: document.getElementById('bgSwatch'),
      statusLeft: document.getElementById('statusLeft'),
      statusRight: document.getElementById('statusRight'),
      size: document.getElementById('size'),
      fontSize: document.getElementById('fontSize'),
      zoom: document.getElementById('zoom'),
      shapeMode: document.getElementById('shapeMode'),
      fillTolerance: document.getElementById('fillTolerance'),
      sprayDensity: document.getElementById('sprayDensity'),
      sprayRadius: document.getElementById('sprayRadius'),
      sprayDensityValue: document.getElementById('sprayDensityValue'),
      sprayRadiusValue: document.getElementById('sprayRadiusValue'),
      fileInput: document.getElementById('fileInput'),
      customColor: document.getElementById('customColor'),
      menuBar: document.getElementById('menuBar'),
      titleMeta: document.getElementById('titleMeta'),
      btnSnapshot: document.getElementById('btnSnapshot'),
      transparentSelection: document.getElementById('transparentSelection'),
      textEditor: textEditorEl
    };

    function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

    async function init() {
      resetCanvas(state.bg);
      buildTools();
      buildPalette();
      wireUI();
      const restored = await restoreSession();
      if (!restored) {
        scheduleIdleTask(() => {
          if (state.history.length === 0) pushHistory();
        }, 1500);
        setStatus('Ready. Right-click palette for background color.');
      }
      refreshSwatches();
      syncControlsFromState();
      updateMeta();
    }

    function scheduleIdleTask(fn, timeout = 1000) {
      if ('requestIdleCallback' in window) {
        window.requestIdleCallback(() => fn(), { timeout });
      } else {
        window.setTimeout(fn, 0);
      }
    }

    function buildTools() {
      els.toolGrid.innerHTML = '';
      TOOLS.forEach((tool) => {
        const btn = document.createElement('button');
        btn.className = `tool ${tool.id === state.tool ? 'active' : ''}`;
        btn.textContent = '';
        const iconEl = document.createElement('span');
        iconEl.className = 'tool-icon';
        if (tool.icon) {
          iconEl.style.backgroundImage = `url("${tool.icon}")`;
        } else {
          iconEl.classList.add('fallback');
          iconEl.textContent = tool.icon || '?';
        }
        btn.appendChild(iconEl);
        btn.title = tool.title;
        btn.dataset.tool = tool.id;
        btn.addEventListener('click', () => handleToolAction(tool.id));
        els.toolGrid.appendChild(btn);
      });
    }

    function buildPalette() {
      els.palette.innerHTML = '';
      let idx = 0;
      const batchSize = 12;
      const renderBatch = () => {
        const frag = document.createDocumentFragment();
        const end = Math.min(COLORS.length, idx + batchSize);
        for (; idx < end; idx += 1) {
          const color = COLORS[idx];
          const cell = document.createElement('button');
          cell.className = 'color';
          cell.style.background = color;
          cell.title = color;
          cell.addEventListener('click', (event) => {
            event.preventDefault();
            state.fg = color;
            refreshSwatches();
          });
          cell.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            state.bg = color;
            refreshSwatches();
          });
          frag.appendChild(cell);
        }
        els.palette.appendChild(frag);
        if (idx < COLORS.length) {
          window.requestAnimationFrame(renderBatch);
        }
      };
      window.requestAnimationFrame(renderBatch);
    }

    function wireUI() {
      holder.addEventListener('pointerdown', onPointerDown);
      holder.addEventListener('pointermove', onPointerMove);
      holder.addEventListener('pointerup', onPointerUp);
      holder.addEventListener('pointercancel', onPointerUp);
      holder.addEventListener('pointerleave', onPointerUp);
      holder.addEventListener('contextmenu', (e) => e.preventDefault());

      selectionEl.addEventListener('pointerdown', onSelectionDragStart);

      els.size.addEventListener('input', () => { state.size = Number(els.size.value); });
      els.fontSize.addEventListener('change', () => { state.fontSize = Number(els.fontSize.value); });
      els.zoom.addEventListener('change', () => { setZoom(Number(els.zoom.value)); });
      els.shapeMode.addEventListener('change', () => { state.shapeMode = els.shapeMode.value; });
      els.fillTolerance.addEventListener('input', () => { state.fillTolerance = Number(els.fillTolerance.value); });
      els.sprayDensity.addEventListener('input', () => {
        state.sprayDensity = Number(els.sprayDensity.value);
        els.sprayDensityValue.textContent = String(state.sprayDensity);
        if (state.tool === 'airbrush') {
          setStatus(`Tool: Spray (Density ${state.sprayDensity}%, Radius ${state.sprayRadius}%)`);
        }
      });
      els.sprayRadius.addEventListener('input', () => {
        state.sprayRadius = Number(els.sprayRadius.value);
        els.sprayRadiusValue.textContent = String(state.sprayRadius);
        if (state.tool === 'airbrush') {
          setStatus(`Tool: Spray (Density ${state.sprayDensity}%, Radius ${state.sprayRadius}%)`);
        }
      });
      els.transparentSelection.addEventListener('change', () => { state.transparentSelection = els.transparentSelection.checked; });

      els.fileInput.addEventListener('change', async (event) => {
        const file = event.target.files?.[0];
        if (!file) return;
        await openImageFile(file);
        event.target.value = '';
      });

      els.customColor.addEventListener('input', () => {
        state.fg = els.customColor.value;
        refreshSwatches();
      });

      els.textEditor.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !event.shiftKey) {
          event.preventDefault();
          commitTextEditor(true);
        }
        if (event.key === 'Escape') {
          event.preventDefault();
          cancelTextEditor();
        }
      });

      els.textEditor.addEventListener('blur', () => {
        // Keep editor open on accidental mobile blur; commit on Enter, tool switch, or canvas click.
      });

      els.btnSnapshot.addEventListener('click', () => {
        pushHistory();
        setStatus('Snapshot saved to undo history.');
      });

      wireMenus();
      scheduleIdleTask(() => {
        wireShortcuts();
        wireClipboard();
      }, 2000);

      window.addEventListener('beforeunload', persistSession);
    }

    function wireMenus() {
      document.querySelectorAll('.menu-item').forEach((item) => {
        item.addEventListener('mouseenter', () => {
          const open = document.querySelector('.menu-item.open');
          if (open && open !== item) {
            open.classList.remove('open');
            item.classList.add('open');
          }
        });
        item.addEventListener('click', (event) => {
          event.stopPropagation();
          const isOpen = item.classList.contains('open');
          closeAllMenus();
          if (!isOpen) item.classList.add('open');
        });
      });

      document.querySelectorAll('.drop-btn').forEach((btn) => {
        btn.addEventListener('click', (event) => {
          event.stopPropagation();
          const action = btn.dataset.action;
          closeAllMenus();
          dispatchAction(action);
        });
      });

      document.addEventListener('click', closeAllMenus);
    }

    function closeAllMenus() {
      document.querySelectorAll('.menu-item.open').forEach((item) => item.classList.remove('open'));
    }

    function wireShortcuts() {
      window.addEventListener('keydown', (event) => {
        if (state.textEditor && event.target === els.textEditor) return;
        const cmd = event.ctrlKey || event.metaKey;
        const key = event.key.toLowerCase();

        if (event.key === 'Delete') {
          event.preventDefault();
          deleteSelection();
          return;
        }

        if (cmd && key === 'z') {
          event.preventDefault();
          undo();
          return;
        }

        if (cmd && key === 'y') {
          event.preventDefault();
          redo();
          return;
        }

        if (cmd && key === 's') {
          event.preventDefault();
          saveImage('png');
          return;
        }

        if (cmd && key === 'o') {
          event.preventDefault();
          els.fileInput.click();
          return;
        }

        if (cmd && key === 'n') {
          event.preventDefault();
          newCanvas();
          return;
        }

        if (cmd && key === 'c') {
          if (state.selection) {
            event.preventDefault();
            copySelection();
          }
          return;
        }

        if (cmd && event.shiftKey && key === 'x') {
          event.preventDefault();
          cropToSelection();
          return;
        }

        if (cmd && key === 'x') {
          if (state.selection) {
            event.preventDefault();
            cutSelection();
          }
          return;
        }

        if (cmd && key === 'v') {
          event.preventDefault();
          pasteSelection();
          return;
        }

        if (!cmd && key === 'g') {
          event.preventDefault();
          toggleGrid();
          return;
        }

        if (!cmd && key === 'x') {
          event.preventDefault();
          swapColors();
          return;
        }

        if (!cmd && key === '+') {
          event.preventDefault();
          dispatchAction('zoom-in');
          return;
        }

        if (!cmd && key === '-') {
          event.preventDefault();
          dispatchAction('zoom-out');
          return;
        }

        if (!cmd && key === '1') {
          event.preventDefault();
          dispatchAction('zoom-reset');
        }
      });
    }

    function wireClipboard() {
      document.addEventListener('paste', async (event) => {
        const items = [...(event.clipboardData?.items || [])];
        const imageItem = items.find((item) => item.type.startsWith('image/'));
        if (!imageItem) return;
        const file = imageItem.getAsFile();
        if (!file) return;
        event.preventDefault();
        await pasteImageAsSelection(await fileToImage(file));
      });
    }

    function dispatchAction(action) {
      if (state.textEditor) commitTextEditor(true);
      switch (action) {
        case 'new': return newCanvas();
        case 'open': return els.fileInput.click();
        case 'save-png': return saveImage('png');
        case 'save-jpg': return saveImage('jpg');
        case 'paste-image': return pasteSelection();
        case 'undo': return undo();
        case 'redo': return redo();
        case 'copy-selection': return copySelection();
        case 'cut-selection': return cutSelection();
        case 'paste-selection': return pasteSelection();
        case 'delete-selection': return deleteSelection();
        case 'zoom-in': return changeZoom(1);
        case 'zoom-out': return changeZoom(-1);
        case 'zoom-reset': return setZoom(1);
        case 'toggle-grid': return toggleGrid();
        case 'crop-selection': return cropToSelection();
        case 'resize-canvas': return resizeCanvasPrompt();
        case 'resize-skew': return resizeSkewPrompt();
        case 'flip-horizontal': return flipCanvas('h');
        case 'flip-vertical': return flipCanvas('v');
        case 'rotate-left': return rotateCanvasLeft();
        case 'rotate-right': return rotateCanvasRight();
        case 'rotate-180': return rotateCanvas180();
        case 'clear': return clearCanvas();
        case 'swap-colors': return swapColors();
        case 'pick-custom': return els.customColor.click();
        case 'invert-colors': return applyFilter('invert');
        case 'grayscale': return applyFilter('grayscale');
        case 'about': return alert('Web Paint Studio\n\nClassic MS Paint inspired drawing app for browser.');
        case 'tips': return alert('Tips:\n- Right click palette = background color\n- Use selection tool then Ctrl+C/Ctrl+V\n- G toggles pixel grid');
        default: return;
      }
    }

    function handleToolAction(toolId) {
      if (state.textEditor && toolId !== 'text') {
        commitTextEditor(true);
      }
      if (state.curveDraft && toolId !== 'curve') {
        state.curveDraft = null;
        pctx.clearRect(0, 0, preview.width, preview.height);
      }
      state.tool = toolId;
      updateToolButtons();
      const activeTool = TOOLS.find((tool) => tool.id === toolId);
      if (toolId === 'airbrush') {
        setStatus(`Tool: ${activeTool ? activeTool.title : toolId} (Density ${state.sprayDensity}%, Radius ${state.sprayRadius}%)`);
      } else {
        setStatus(`Tool: ${activeTool ? activeTool.title : toolId}`);
      }
    }

    function updateToolButtons() {
      document.querySelectorAll('.tool').forEach((btn) => {
        btn.classList.toggle('active', btn.dataset.tool === state.tool);
      });
      if (state.tool === 'eyedropper') {
        holder.style.cursor = 'copy';
      } else if (state.tool === 'magnifier') {
        holder.style.cursor = 'zoom-in';
      } else if (state.tool === 'airbrush') {
        holder.style.cursor = 'crosshair';
      } else if (state.tool === 'select') {
        holder.style.cursor = 'crosshair';
      } else {
        holder.style.cursor = 'crosshair';
      }
    }

    function refreshSwatches() {
      els.fgSwatch.style.background = state.fg;
      els.bgSwatch.style.background = state.bg;
      queuePersistSession();
    }

    function setStatus(message) {
      els.statusLeft.textContent = message;
    }

    function updateMeta() {
      els.titleMeta.textContent = `${state.fileName} - ${canvas.width}x${canvas.height}`;
      queuePersistSession();
    }

    function syncControlsFromState() {
      els.size.value = String(state.size);
      els.fontSize.value = String(state.fontSize);
      els.zoom.value = String(state.zoom);
      els.shapeMode.value = state.shapeMode;
      els.fillTolerance.value = String(state.fillTolerance);
      els.sprayDensity.value = String(state.sprayDensity);
      els.sprayRadius.value = String(state.sprayRadius);
      els.sprayDensityValue.textContent = String(state.sprayDensity);
      els.sprayRadiusValue.textContent = String(state.sprayRadius);
      els.transparentSelection.checked = Boolean(state.transparentSelection);
    }

    function queuePersistSession() {
      if (persistTimer) window.clearTimeout(persistTimer);
      persistTimer = window.setTimeout(() => {
        persistSession();
      }, 700);
    }

    function persistSession() {
      try {
        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = canvas.width;
        exportCanvas.height = canvas.height;
        const ex = exportCanvas.getContext('2d');
        ex.drawImage(canvas, 0, 0);
        if (state.selection) {
          drawSelectionToContext(ex);
        }
        const payload = {
          v: 1,
          ts: Date.now(),
          width: canvas.width,
          height: canvas.height,
          fileName: state.fileName,
          fg: state.fg,
          bg: state.bg,
          size: state.size,
          fontSize: state.fontSize,
          zoom: state.zoom,
          shapeMode: state.shapeMode,
          fillTolerance: state.fillTolerance,
          sprayDensity: state.sprayDensity,
          sprayRadius: state.sprayRadius,
          transparentSelection: state.transparentSelection,
          image: exportCanvas.toDataURL('image/png')
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      } catch (_err) {
        // Ignore storage errors (quota/private mode) and keep the editor usable.
      }
    }

    async function restoreSession() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return false;
        const payload = JSON.parse(raw);
        if (!payload || !payload.image) return false;

        const savedW = clamp(Number(payload.width) || canvas.width, 1, 5000);
        const savedH = clamp(Number(payload.height) || canvas.height, 1, 5000);
        if (savedW !== canvas.width || savedH !== canvas.height) {
          canvas.width = savedW;
          canvas.height = savedH;
          preview.width = savedW;
          preview.height = savedH;
          holder.style.width = `${savedW}px`;
          holder.style.height = `${savedH}px`;
        }

        state.fileName = (payload.fileName && String(payload.fileName).trim()) || 'Untitled';
        state.fg = payload.fg || state.fg;
        state.bg = payload.bg || state.bg;
        state.size = clamp(Number(payload.size) || state.size, 1, 72);
        state.fontSize = clamp(Number(payload.fontSize) || state.fontSize, 8, 128);
        state.zoom = [0.5, 1, 2, 4, 8].includes(Number(payload.zoom)) ? Number(payload.zoom) : 1;
        state.shapeMode = ['stroke', 'fill', 'both'].includes(payload.shapeMode) ? payload.shapeMode : 'stroke';
        state.fillTolerance = clamp(Number(payload.fillTolerance) || state.fillTolerance, 0, 120);
        state.sprayDensity = clamp(Number(payload.sprayDensity) || state.sprayDensity, 0, 100);
        state.sprayRadius = clamp(Number(payload.sprayRadius) || state.sprayRadius, 0, 100);
        state.transparentSelection = Boolean(payload.transparentSelection);

        await new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            resetCanvas(state.bg);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            resolve();
          };
          img.onerror = reject;
          img.src = payload.image;
        });

        setZoom(state.zoom);
        pushHistory();
        setStatus('Restored previous session');
        return true;
      } catch (_err) {
        return false;
      }
    }

    function startTextEditor(x, y) {
      clearSelection(true);
      const te = els.textEditor;
      te.classList.remove('hidden');
      te.style.left = `${x}px`;
      te.style.top = `${y}px`;
      te.style.width = '220px';
      te.style.height = `${Math.max(24, state.fontSize + 8)}px`;
      te.style.fontSize = `${state.fontSize}px`;
      te.style.color = state.fg;
      te.value = '';
      state.textEditor = { x, y };
      te.focus();
      setStatus('Type text. Enter to commit, Esc to cancel.');
    }

    function commitTextEditor(push) {
      if (!state.textEditor) return;
      const te = els.textEditor;
      const text = te.value || '';
      if (text.trim().length) {
        const x = parseInt(te.style.left, 10) || state.textEditor.x || 0;
        const y = parseInt(te.style.top, 10) || state.textEditor.y || 0;
        const width = Math.max(1, te.offsetWidth);
        const lineHeight = state.fontSize + 4;
        ctx.fillStyle = state.fg;
        ctx.font = `${state.fontSize}px Tahoma, sans-serif`;
        const lines = text.replace(/\r/g, '').split('\n');
        lines.forEach((line, idx) => {
          const ly = y + state.fontSize + idx * lineHeight;
          ctx.fillText(line, x, ly, width);
        });
        if (push) pushHistory();
      }
      te.value = '';
      te.classList.add('hidden');
      state.textEditor = null;
    }

    function cancelTextEditor() {
      if (!state.textEditor) return;
      els.textEditor.value = '';
      els.textEditor.classList.add('hidden');
      state.textEditor = null;
      setStatus('Text canceled');
    }

    function toCanvasPoint(event) {
      const rect = holder.getBoundingClientRect();
      const x = Math.floor((event.clientX - rect.left) / state.zoom);
      const y = Math.floor((event.clientY - rect.top) / state.zoom);
      return {
        x: clamp(x, 0, canvas.width - 1),
        y: clamp(y, 0, canvas.height - 1)
      };
    }

    function onPointerDown(event) {
      if (state.textEditor && event.target !== els.textEditor && !els.textEditor.contains(event.target)) {
        commitTextEditor(true);
      }

      if (state.selection && selectionHit(event)) return;

      const p = toCanvasPoint(event);

      if (state.tool === 'magnifier') {
        if (event.button === 2) {
          changeZoom(-1);
        } else {
          changeZoom(1);
        }
        return;
      }

      if (state.tool === 'text') {
        startTextEditor(p.x, p.y);
        return;
      }

      state.drawing = true;
      state.pointerId = event.pointerId;
      holder.setPointerCapture(event.pointerId);
      state.startX = p.x;
      state.startY = p.y;
      state.lastX = p.x;
      state.lastY = p.y;

      if (!['select', 'freeselect'].includes(state.tool) && state.selection) {
        stampSelection(true);
      }

      if (state.tool === 'fill') {
        floodFill(p.x, p.y, state.fg, state.fillTolerance);
        pushHistory();
        state.drawing = false;
        return;
      }

      if (state.tool === 'eyedropper') {
        const pixel = ctx.getImageData(p.x, p.y, 1, 1).data;
        state.fg = rgbToHex(pixel[0], pixel[1], pixel[2]);
        refreshSwatches();
        state.drawing = false;
        setStatus(`Picked ${state.fg}`);
        return;
      }

      if (state.tool === 'pencil' || state.tool === 'brush' || state.tool === 'eraser') {
        if (state.tool === 'brush') {
          drawBrushDab(p.x, p.y);
        } else {
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';
          ctx.lineWidth = state.size;
          ctx.strokeStyle = state.tool === 'eraser' ? state.bg : state.fg;
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(p.x, p.y);
          ctx.stroke();
        }
      }

      if (state.tool === 'airbrush') {
        sprayAt(p.x, p.y);
        state.sprayTimer = window.setInterval(() => sprayAt(state.lastX, state.lastY), 24);
      }

      if (state.tool === 'curve' && state.curveDraft && state.curveDraft.awaitControl) {
        state.startX = p.x;
        state.startY = p.y;
      }

      if (state.tool === 'freeselect') {
        state.freeSelectPath = [{ x: p.x, y: p.y }];
        previewFreeSelection(state.freeSelectPath);
      }
    }

    function onPointerMove(event) {
      const p = toCanvasPoint(event);
      els.statusRight.textContent = `x:${p.x} y:${p.y}`;

      if (state.selectionDrag) {
        dragSelection(event);
        return;
      }

      if (!state.drawing) return;

      if (state.tool === 'pencil' || state.tool === 'brush' || state.tool === 'eraser') {
        if (state.tool === 'brush') {
          drawBrushStroke(state.lastX, state.lastY, p.x, p.y);
        } else {
          ctx.lineTo(p.x, p.y);
          ctx.stroke();
        }
        state.lastX = p.x;
        state.lastY = p.y;
        return;
      }

      if (state.tool === 'airbrush') {
        sprayAt(p.x, p.y);
        state.lastX = p.x;
        state.lastY = p.y;
        return;
      }

      if (state.tool === 'curve') {
        if (state.curveDraft && state.curveDraft.awaitControl) {
          previewCurve(state.curveDraft, p.x, p.y);
        } else {
          previewShape(state.startX, state.startY, p.x, p.y, 'line');
        }
        return;
      }

      if (state.tool === 'freeselect') {
        if (!state.freeSelectPath) state.freeSelectPath = [{ x: state.startX, y: state.startY }];
        state.freeSelectPath.push({ x: p.x, y: p.y });
        previewFreeSelection(state.freeSelectPath);
        return;
      }

      if (['line', 'polygon', 'rect', 'ellipse', 'roundrect', 'select'].includes(state.tool)) {
        previewShape(state.startX, state.startY, p.x, p.y, state.tool);
      }
    }

    function onPointerUp(event) {
      if (state.sprayTimer && event.pointerId === state.pointerId) {
        window.clearInterval(state.sprayTimer);
        state.sprayTimer = null;
      }
      if (state.selectionDrag) {
        endSelectionDrag();
        return;
      }
      if (!state.drawing) return;
      if (state.pointerId !== null && event.pointerId !== state.pointerId) return;

      const p = toCanvasPoint(event);
      state.drawing = false;

      if (state.tool === 'curve') {
        if (!state.curveDraft) {
          state.curveDraft = {
            x1: state.startX,
            y1: state.startY,
            x2: p.x,
            y2: p.y,
            awaitControl: true
          };
          previewShape(state.curveDraft.x1, state.curveDraft.y1, state.curveDraft.x2, state.curveDraft.y2, 'line');
          setStatus('Curve step 2: drag to bend curve');
        } else {
          commitCurve(state.curveDraft, p.x, p.y);
          state.curveDraft = null;
          pushHistory();
          setStatus('Curve drawn');
        }
        state.pointerId = null;
        return;
      }

      if (['line', 'polygon', 'rect', 'ellipse', 'roundrect'].includes(state.tool)) {
        commitShape(state.startX, state.startY, p.x, p.y, state.tool);
        pushHistory();
      }

      if (state.tool === 'select') {
        createSelection(state.startX, state.startY, p.x, p.y);
      }

      if (state.tool === 'freeselect') {
        createFreeSelection(state.freeSelectPath || []);
        state.freeSelectPath = null;
      }

      if (['pencil', 'brush', 'eraser', 'airbrush'].includes(state.tool)) {
        pushHistory();
      }
      if (state.sprayTimer) {
        window.clearInterval(state.sprayTimer);
        state.sprayTimer = null;
      }

      if (state.tool !== 'freeselect') {
        pctx.clearRect(0, 0, preview.width, preview.height);
      }
      state.pointerId = null;
    }

    function previewShape(x1, y1, x2, y2, kind) {
      pctx.clearRect(0, 0, preview.width, preview.height);
      pctx.strokeStyle = state.fg;
      pctx.fillStyle = state.bg;
      pctx.lineWidth = state.size;
      pctx.setLineDash(kind === 'select' ? [4, 3] : [5, 3]);
      drawShape(pctx, x1, y1, x2, y2, kind, state.shapeMode);
      pctx.setLineDash([]);
    }

    function commitShape(x1, y1, x2, y2, kind) {
      ctx.strokeStyle = state.fg;
      ctx.fillStyle = state.bg;
      ctx.lineWidth = state.size;
      drawShape(ctx, x1, y1, x2, y2, kind, state.shapeMode);
      pctx.clearRect(0, 0, preview.width, preview.height);
    }

    function drawShape(target, x1, y1, x2, y2, kind, mode) {
      const x = Math.min(x1, x2);
      const y = Math.min(y1, y2);
      const w = Math.abs(x2 - x1);
      const h = Math.abs(y2 - y1);

      if (kind === 'line') {
        target.beginPath();
        target.moveTo(x1, y1);
        target.lineTo(x2, y2);
        target.stroke();
        return;
      }

      if (kind === 'polygon') {
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const rx = Math.max(1, w / 2);
        const ry = Math.max(1, h / 2);
        const sides = 6;
        target.beginPath();
        for (let i = 0; i < sides; i += 1) {
          const angle = -Math.PI / 2 + (i * Math.PI * 2) / sides;
          const px = cx + Math.cos(angle) * rx;
          const py = cy + Math.sin(angle) * ry;
          if (i === 0) target.moveTo(px, py);
          else target.lineTo(px, py);
        }
        target.closePath();
        if (mode === 'fill' || mode === 'both') target.fill();
        if (mode === 'stroke' || mode === 'both') target.stroke();
        return;
      }

      if (kind === 'rect' || kind === 'select') {
        if (mode === 'fill' || mode === 'both') target.fillRect(x, y, w, h);
        if (mode === 'stroke' || mode === 'both' || kind === 'select') target.strokeRect(x, y, w, h);
        return;
      }

      if (kind === 'ellipse') {
        target.beginPath();
        target.ellipse((x1 + x2) / 2, (y1 + y2) / 2, Math.max(1, w / 2), Math.max(1, h / 2), 0, 0, Math.PI * 2);
        if (mode === 'fill' || mode === 'both') target.fill();
        if (mode === 'stroke' || mode === 'both') target.stroke();
        return;
      }

      if (kind === 'roundrect') {
        roundedRectPath(target, x, y, w, h, Math.max(4, Math.min(w, h) * 0.15));
        if (mode === 'fill' || mode === 'both') target.fill();
        if (mode === 'stroke' || mode === 'both') target.stroke();
      }
    }

    function previewCurve(curve, controlX, controlY) {
      pctx.clearRect(0, 0, preview.width, preview.height);
      pctx.strokeStyle = state.fg;
      pctx.lineWidth = state.size;
      pctx.setLineDash([5, 3]);
      pctx.beginPath();
      pctx.moveTo(curve.x1, curve.y1);
      pctx.quadraticCurveTo(controlX, controlY, curve.x2, curve.y2);
      pctx.stroke();
      pctx.setLineDash([]);
    }

    function commitCurve(curve, controlX, controlY) {
      ctx.strokeStyle = state.fg;
      ctx.lineWidth = state.size;
      ctx.beginPath();
      ctx.moveTo(curve.x1, curve.y1);
      ctx.quadraticCurveTo(controlX, controlY, curve.x2, curve.y2);
      ctx.stroke();
      pctx.clearRect(0, 0, preview.width, preview.height);
    }

    function roundedRectPath(target, x, y, w, h, r) {
      const rr = Math.min(r, Math.floor(w / 2), Math.floor(h / 2));
      target.beginPath();
      target.moveTo(x + rr, y);
      target.lineTo(x + w - rr, y);
      target.quadraticCurveTo(x + w, y, x + w, y + rr);
      target.lineTo(x + w, y + h - rr);
      target.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
      target.lineTo(x + rr, y + h);
      target.quadraticCurveTo(x, y + h, x, y + h - rr);
      target.lineTo(x, y + rr);
      target.quadraticCurveTo(x, y, x + rr, y);
      target.closePath();
    }

    function drawBrushDab(x, y) {
      const radius = Math.max(2, Math.floor(state.size * 1.4));
      ctx.save();
      ctx.fillStyle = state.fg;
      ctx.globalAlpha = 0.95;
      ctx.beginPath();
      ctx.ellipse(x, y, radius, Math.max(2, radius * 0.7), Math.PI / 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    function drawBrushStroke(x1, y1, x2, y2) {
      const steps = Math.max(1, Math.floor(Math.hypot(x2 - x1, y2 - y1) / 2));
      for (let i = 0; i <= steps; i += 1) {
        const t = i / steps;
        const x = Math.round(x1 + (x2 - x1) * t);
        const y = Math.round(y1 + (y2 - y1) * t);
        drawBrushDab(x, y);
      }
    }

    function sprayAt(x, y) {
      const radiusPct = clamp(state.sprayRadius, 0, 100);
      const densityPct = clamp(state.sprayDensity, 0, 100);
      const radius = Math.max(2, Math.round(2 + radiusPct * 0.7));
      const count = Math.max(4, Math.round(3 + densityPct * 2.2 + densityPct * densityPct * 0.04));
      const dotSize = Math.max(1, Math.floor(state.size / 5));
      ctx.fillStyle = state.fg;
      ctx.save();
      ctx.globalAlpha = clamp(0.14 + densityPct / 120, 0.14, 0.92);
      for (let i = 0; i < count; i += 1) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.sqrt(Math.random()) * radius;
        const jitter = (Math.random() - 0.5) * Math.max(1, radius * 0.14);
        const px = Math.round(x + Math.cos(angle) * dist + jitter);
        const py = Math.round(y + Math.sin(angle) * dist + jitter);
        if (px >= 0 && py >= 0 && px < canvas.width && py < canvas.height) {
          ctx.fillRect(px, py, dotSize, dotSize);
        }
      }
      ctx.restore();
    }

    function floodFill(x, y, hex, tolerance) {
      const image = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = image.data;
      const idx = (y * canvas.width + x) * 4;
      const target = [data[idx], data[idx + 1], data[idx + 2], data[idx + 3]];
      const fill = hexToRgba(hex);

      if (nearColor(target, fill, 0)) return;

      const q = [[x, y]];
      const seen = new Uint8Array(canvas.width * canvas.height);

      while (q.length) {
        const [cx, cy] = q.pop();
        if (cx < 0 || cy < 0 || cx >= canvas.width || cy >= canvas.height) continue;
        const qi = cy * canvas.width + cx;
        if (seen[qi]) continue;
        seen[qi] = 1;

        const di = qi * 4;
        const pix = [data[di], data[di + 1], data[di + 2], data[di + 3]];
        if (!nearColor(pix, target, tolerance)) continue;

        data[di] = fill[0];
        data[di + 1] = fill[1];
        data[di + 2] = fill[2];
        data[di + 3] = 255;

        q.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
      }

      ctx.putImageData(image, 0, 0);
    }

    function nearColor(a, b, tolerance) {
      return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]) + Math.abs(a[2] - b[2]) <= tolerance;
    }

    function hexToRgba(hex) {
      const clean = hex.replace('#', '');
      return [
        parseInt(clean.slice(0, 2), 16),
        parseInt(clean.slice(2, 4), 16),
        parseInt(clean.slice(4, 6), 16),
        255
      ];
    }

    function rgbToHex(r, g, b) {
      return `#${[r, g, b].map((v) => v.toString(16).padStart(2, '0')).join('')}`;
    }

    function pushHistory() {
      state.history.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
      if (state.history.length > state.maxHistory) state.history.shift();
      state.future = [];
      queuePersistSession();
    }

    function undo() {
      if (state.selection) stampSelection(false);
      if (state.history.length <= 1) return;
      const current = state.history.pop();
      state.future.push(current);
      const prev = state.history[state.history.length - 1];
      ctx.putImageData(prev, 0, 0);
      setStatus('Undo');
    }

    function redo() {
      if (state.selection) stampSelection(false);
      if (!state.future.length) return;
      const next = state.future.pop();
      state.history.push(next);
      ctx.putImageData(next, 0, 0);
      setStatus('Redo');
    }

    function resetCanvas(color) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = color;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      pctx.clearRect(0, 0, preview.width, preview.height);
      clearSelection(true);
    }

    function clearCanvas() {
      if (state.selection) stampSelection(false);
      if (!confirm('Clear image?')) return;
      resetCanvas(state.bg);
      pushHistory();
      setStatus('Image cleared');
    }

    function newCanvas() {
      if (state.selection) stampSelection(false);
      if (!confirm('Create new image? Unsaved changes will remain only in this tab.')) return;
      state.fileName = 'Untitled';
      resetCanvas(state.bg);
      state.history = [];
      state.future = [];
      pushHistory();
      updateMeta();
      setStatus('New image created');
    }

    async function fileToImage(file) {
      const url = URL.createObjectURL(file);
      const img = new Image();
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = reject;
        img.src = url;
      });
      URL.revokeObjectURL(url);
      return img;
    }

    async function openImageFile(file) {
      if (state.selection) stampSelection(false);
      const img = await fileToImage(file);
      const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
      const w = Math.max(1, Math.round(img.width * scale));
      const h = Math.max(1, Math.round(img.height * scale));
      const x = Math.floor((canvas.width - w) / 2);
      const y = Math.floor((canvas.height - h) / 2);

      resetCanvas(state.bg);
      ctx.drawImage(img, x, y, w, h);
      pushHistory();

      state.fileName = file.name.replace(/\.[^.]+$/, '') || 'Image';
      updateMeta();
      setStatus(`Opened ${file.name}`);
    }

    function saveImage(type) {
      const mime = type === 'jpg' ? 'image/jpeg' : 'image/png';
      const ext = type === 'jpg' ? 'jpg' : 'png';
      let dataUrl = '';
      if (state.selection) {
        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = canvas.width;
        exportCanvas.height = canvas.height;
        const ex = exportCanvas.getContext('2d');
        ex.drawImage(canvas, 0, 0);
        drawSelectionToContext(ex);
        dataUrl = exportCanvas.toDataURL(mime, 0.92);
      } else {
        dataUrl = canvas.toDataURL(mime, 0.92);
      }
      const a = document.createElement('a');
      a.href = dataUrl;
      a.download = `${state.fileName || 'drawing'}-${Date.now()}.${ext}`;
      a.click();
      setStatus(`Saved ${ext.toUpperCase()}`);
    }

    function setZoom(v) {
      state.zoom = v;
      holder.style.transform = `scale(${v})`;
      els.zoom.value = String(v);
      updateGrid();
      setStatus(`Zoom ${Math.round(v * 100)}%`);
      queuePersistSession();
    }

    function changeZoom(delta) {
      const levels = [0.5, 1, 2, 4, 8];
      const idx = levels.indexOf(state.zoom);
      const next = clamp(idx + delta, 0, levels.length - 1);
      setZoom(levels[next]);
    }

    function toggleGrid() {
      state.pixelGrid = !state.pixelGrid;
      updateGrid();
      setStatus(state.pixelGrid ? 'Pixel grid ON' : 'Pixel grid OFF');
    }

    function updateGrid() {
      if (state.pixelGrid && state.zoom >= 4) {
        holder.style.backgroundImage = 'linear-gradient(rgba(0,0,0,0.08) 1px, transparent 1px), linear-gradient(90deg, rgba(0,0,0,0.08) 1px, transparent 1px)';
        holder.style.backgroundSize = `${state.zoom}px ${state.zoom}px`;
      } else {
        holder.style.backgroundImage = 'none';
      }
    }

    function resizeCanvasPrompt() {
      const w = Number(prompt('Canvas width (px)', String(canvas.width)));
      if (!Number.isFinite(w) || w < 1) return;
      const h = Number(prompt('Canvas height (px)', String(canvas.height)));
      if (!Number.isFinite(h) || h < 1) return;
      resizeCanvas(w, h);
    }

    function resizeSkewPrompt() {
      const widthPercent = Number(prompt('Resize width (%)', '100'));
      if (!Number.isFinite(widthPercent) || widthPercent <= 0) return;
      const heightPercent = Number(prompt('Resize height (%)', '100'));
      if (!Number.isFinite(heightPercent) || heightPercent <= 0) return;
      const skewX = Number(prompt('Skew horizontally (degrees, -89 to 89)', '0'));
      if (!Number.isFinite(skewX) || Math.abs(skewX) >= 89) return;
      const skewY = Number(prompt('Skew vertically (degrees, -89 to 89)', '0'));
      if (!Number.isFinite(skewY) || Math.abs(skewY) >= 89) return;
      resizeAndSkew(widthPercent / 100, heightPercent / 100, skewX, skewY);
    }

    function resizeCanvas(newW, newH) {
      if (state.selection) stampSelection(false);
      const snapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
      canvas.width = clamp(Math.round(newW), 1, 5000);
      canvas.height = clamp(Math.round(newH), 1, 5000);
      preview.width = canvas.width;
      preview.height = canvas.height;
      holder.style.width = `${canvas.width}px`;
      holder.style.height = `${canvas.height}px`;

      resetCanvas(state.bg);
      const putW = Math.min(snapshot.width, canvas.width);
      const putH = Math.min(snapshot.height, canvas.height);
      ctx.putImageData(snapshot, 0, 0, 0, 0, putW, putH);
      pushHistory();
      clearSelection(true);
      updateMeta();
      setStatus(`Canvas resized to ${canvas.width}x${canvas.height}`);
    }

    function resizeAndSkew(scaleX, scaleY, skewXDeg, skewYDeg) {
      if (state.selection) stampSelection(false);

      const src = document.createElement('canvas');
      src.width = canvas.width;
      src.height = canvas.height;
      src.getContext('2d').drawImage(canvas, 0, 0);

      const scaledW = clamp(Math.round(src.width * scaleX), 1, 8000);
      const scaledH = clamp(Math.round(src.height * scaleY), 1, 8000);
      const scaled = document.createElement('canvas');
      scaled.width = scaledW;
      scaled.height = scaledH;
      scaled.getContext('2d').drawImage(src, 0, 0, scaledW, scaledH);

      const skewX = Math.tan((skewXDeg * Math.PI) / 180);
      const skewY = Math.tan((skewYDeg * Math.PI) / 180);
      const offsetX = Math.abs(skewX) * scaledH;
      const offsetY = Math.abs(skewY) * scaledW;
      const outW = clamp(Math.ceil(scaledW + offsetX), 1, 8000);
      const outH = clamp(Math.ceil(scaledH + offsetY), 1, 8000);

      canvas.width = outW;
      canvas.height = outH;
      preview.width = outW;
      preview.height = outH;
      holder.style.width = `${outW}px`;
      holder.style.height = `${outH}px`;

      resetCanvas(state.bg);
      ctx.save();
      ctx.setTransform(1, skewY, skewX, 1, skewX < 0 ? offsetX : 0, skewY < 0 ? offsetY : 0);
      ctx.drawImage(scaled, 0, 0);
      ctx.restore();
      pushHistory();
      clearSelection(true);
      updateMeta();
      setStatus(`Resize/Skew applied: ${Math.round(scaleX * 100)}% x ${Math.round(scaleY * 100)}%, skew ${skewXDeg}°, ${skewYDeg}°`);
    }

    function cropToSelection() {
      if (!state.selection) {
        setStatus('Select an area first to crop');
        return;
      }

      const s = state.selection;
      const temp = document.createElement('canvas');
      temp.width = s.w;
      temp.height = s.h;
      temp.getContext('2d').putImageData(s.imageData, 0, 0);

      canvas.width = s.w;
      canvas.height = s.h;
      preview.width = s.w;
      preview.height = s.h;
      holder.style.width = `${s.w}px`;
      holder.style.height = `${s.h}px`;

      resetCanvas(state.bg);
      ctx.drawImage(temp, 0, 0);
      clearSelection(true);
      pushHistory();
      updateMeta();
      setStatus(`Cropped to ${s.w}x${s.h}`);
    }

    function transformCanvas(transformer) {
      const temp = document.createElement('canvas');
      temp.width = canvas.width;
      temp.height = canvas.height;
      const tctx = temp.getContext('2d');
      transformer(tctx);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(temp, 0, 0);
      pushHistory();
    }

    function flipCanvas(axis) {
      if (state.selection) stampSelection(false);
      const image = document.createElement('canvas');
      image.width = canvas.width;
      image.height = canvas.height;
      const ictx = image.getContext('2d');
      ictx.drawImage(canvas, 0, 0);

      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (axis === 'h') {
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
      } else {
        ctx.translate(0, canvas.height);
        ctx.scale(1, -1);
      }
      ctx.drawImage(image, 0, 0);
      ctx.restore();
      pushHistory();
      setStatus(axis === 'h' ? 'Flipped horizontally' : 'Flipped vertically');
    }

    function rotateCanvasRight() {
      if (state.selection) stampSelection(false);
      const src = document.createElement('canvas');
      src.width = canvas.width;
      src.height = canvas.height;
      src.getContext('2d').drawImage(canvas, 0, 0);

      const oldW = canvas.width;
      const oldH = canvas.height;
      canvas.width = oldH;
      canvas.height = oldW;
      preview.width = canvas.width;
      preview.height = canvas.height;
      holder.style.width = `${canvas.width}px`;
      holder.style.height = `${canvas.height}px`;

      ctx.save();
      ctx.translate(canvas.width, 0);
      ctx.rotate(Math.PI / 2);
      ctx.drawImage(src, 0, 0);
      ctx.restore();
      pushHistory();
      clearSelection(true);
      updateMeta();
      setStatus('Rotated 90° right');
    }

    function rotateCanvasLeft() {
      if (state.selection) stampSelection(false);
      const src = document.createElement('canvas');
      src.width = canvas.width;
      src.height = canvas.height;
      src.getContext('2d').drawImage(canvas, 0, 0);

      const oldW = canvas.width;
      const oldH = canvas.height;
      canvas.width = oldH;
      canvas.height = oldW;
      preview.width = canvas.width;
      preview.height = canvas.height;
      holder.style.width = `${canvas.width}px`;
      holder.style.height = `${canvas.height}px`;

      ctx.save();
      ctx.translate(0, canvas.height);
      ctx.rotate(-Math.PI / 2);
      ctx.drawImage(src, 0, 0);
      ctx.restore();
      pushHistory();
      clearSelection(true);
      updateMeta();
      setStatus('Rotated 90° left');
    }

    function rotateCanvas180() {
      if (state.selection) stampSelection(false);
      const src = document.createElement('canvas');
      src.width = canvas.width;
      src.height = canvas.height;
      src.getContext('2d').drawImage(canvas, 0, 0);

      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.translate(canvas.width, canvas.height);
      ctx.rotate(Math.PI);
      ctx.drawImage(src, 0, 0);
      ctx.restore();
      pushHistory();
      clearSelection(true);
      setStatus('Rotated 180°');
    }

    function applyFilter(type) {
      if (state.selection) stampSelection(false);
      const image = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const d = image.data;
      for (let i = 0; i < d.length; i += 4) {
        if (type === 'invert') {
          d[i] = 255 - d[i];
          d[i + 1] = 255 - d[i + 1];
          d[i + 2] = 255 - d[i + 2];
        }
        if (type === 'grayscale') {
          const g = Math.round(0.299 * d[i] + 0.587 * d[i + 1] + 0.114 * d[i + 2]);
          d[i] = g;
          d[i + 1] = g;
          d[i + 2] = g;
        }
      }
      ctx.putImageData(image, 0, 0);
      pushHistory();
      setStatus(type === 'invert' ? 'Inverted colors' : 'Applied grayscale');
    }

    function swapColors() {
      const t = state.fg;
      state.fg = state.bg;
      state.bg = t;
      refreshSwatches();
      setStatus('Swapped foreground/background colors');
    }

    function pathFromPoints(target, points, offsetX = 0, offsetY = 0) {
      if (!points.length) return;
      target.beginPath();
      target.moveTo(points[0].x + offsetX, points[0].y + offsetY);
      for (let i = 1; i < points.length; i += 1) {
        target.lineTo(points[i].x + offsetX, points[i].y + offsetY);
      }
      target.closePath();
    }

    function previewFreeSelection(points) {
      pctx.clearRect(0, 0, preview.width, preview.height);
      if (!points || points.length < 2) return;
      pctx.save();
      pctx.setLineDash([4, 3]);
      pctx.strokeStyle = state.fg;
      pctx.lineWidth = 1;
      pathFromPoints(pctx, points);
      pctx.stroke();
      pctx.restore();
    }

    function createFreeSelection(points) {
      pctx.clearRect(0, 0, preview.width, preview.height);
      if (!points || points.length < 3) {
        clearSelection(true);
        return;
      }

      let minX = canvas.width;
      let minY = canvas.height;
      let maxX = 0;
      let maxY = 0;
      for (const pt of points) {
        minX = Math.min(minX, pt.x);
        minY = Math.min(minY, pt.y);
        maxX = Math.max(maxX, pt.x);
        maxY = Math.max(maxY, pt.y);
      }

      const x = clamp(Math.floor(minX), 0, canvas.width - 1);
      const y = clamp(Math.floor(minY), 0, canvas.height - 1);
      const w = clamp(Math.ceil(maxX - minX) + 1, 1, canvas.width - x);
      const h = clamp(Math.ceil(maxY - minY) + 1, 1, canvas.height - y);
      if (w < 2 || h < 2) {
        clearSelection(true);
        return;
      }

      const source = ctx.getImageData(x, y, w, h);
      const masked = new Uint8ClampedArray(source.data);
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = w;
      maskCanvas.height = h;
      const mctx = maskCanvas.getContext('2d');
      mctx.fillStyle = '#000';
      pathFromPoints(mctx, points, -x, -y);
      mctx.fill();
      const maskData = mctx.getImageData(0, 0, w, h).data;

      for (let i = 0; i < masked.length; i += 4) {
        if (maskData[i + 3] === 0) {
          masked[i + 3] = 0;
        }
      }

      state.selection = {
        x,
        y,
        w,
        h,
        imageData: new ImageData(masked, w, h)
      };

      if (!state.transparentSelection) {
        ctx.save();
        pathFromPoints(ctx, points);
        ctx.clip();
        ctx.fillStyle = state.bg;
        ctx.fillRect(x, y, w, h);
        ctx.restore();
      }

      renderSelection();
      pushHistory();
      setStatus(`Free-form selection ${w}x${h}`);
    }

    function selectionHit(event) {
      const target = event.target;
      return target === selectionEl;
    }

    function createSelection(x1, y1, x2, y2) {
      const x = Math.min(x1, x2);
      const y = Math.min(y1, y2);
      const w = Math.abs(x2 - x1);
      const h = Math.abs(y2 - y1);
      if (w < 2 || h < 2) {
        clearSelection(true);
        return;
      }

      const data = ctx.getImageData(x, y, w, h);
      state.selection = { x, y, w, h, imageData: data };
      if (!state.transparentSelection) {
        ctx.fillStyle = state.bg;
        ctx.fillRect(x, y, w, h);
      }
      renderSelection();
      pushHistory();
      setStatus(`Selection ${w}x${h}`);
    }

    function renderSelection() {
      if (!state.selection) {
        selectionEl.style.display = 'none';
        return;
      }
      const s = state.selection;
      selectionEl.style.display = 'block';
      selectionEl.style.left = `${s.x}px`;
      selectionEl.style.top = `${s.y}px`;
      selectionEl.style.width = `${s.w}px`;
      selectionEl.style.height = `${s.h}px`;

      const temp = document.createElement('canvas');
      temp.width = s.w;
      temp.height = s.h;
      temp.getContext('2d').putImageData(s.imageData, 0, 0);
      selectionEl.style.backgroundImage = `url(${temp.toDataURL('image/png')})`;
      selectionEl.style.backgroundSize = '100% 100%';
      selectionEl.style.backgroundRepeat = 'no-repeat';
    }

    function onSelectionDragStart(event) {
      if (!state.selection) return;
      event.stopPropagation();
      const p = toCanvasPoint(event);
      state.selectionDrag = {
        pointerId: event.pointerId,
        offsetX: p.x - state.selection.x,
        offsetY: p.y - state.selection.y
      };
      selectionEl.classList.add('dragging');
      selectionEl.setPointerCapture(event.pointerId);
    }

    function dragSelection(event) {
      const drag = state.selectionDrag;
      if (!drag || event.pointerId !== drag.pointerId) return;
      const p = toCanvasPoint(event);
      const s = state.selection;
      s.x = clamp(p.x - drag.offsetX, 0, canvas.width - s.w);
      s.y = clamp(p.y - drag.offsetY, 0, canvas.height - s.h);
      renderSelection();
    }

    function endSelectionDrag() {
      if (!state.selectionDrag || !state.selection) return;
      selectionEl.classList.remove('dragging');
      state.selectionDrag = null;
      renderSelection();
      setStatus('Selection moved');
    }

    function drawSelectionToContext(targetCtx) {
      if (!state.selection) return;
      const s = state.selection;
      const temp = document.createElement('canvas');
      temp.width = s.w;
      temp.height = s.h;
      temp.getContext('2d').putImageData(s.imageData, 0, 0);
      targetCtx.drawImage(temp, s.x, s.y);
    }

    function stampSelection(push) {
      if (!state.selection) return;
      drawSelectionToContext(ctx);
      clearSelection(true);
      if (push) pushHistory();
      setStatus('Selection committed');
    }

    function clearSelection(silent) {
      state.selection = null;
      state.selectionDrag = null;
      selectionEl.style.display = 'none';
      selectionEl.style.backgroundImage = 'none';
      if (!silent) setStatus('Selection cleared');
    }

    function copySelection() {
      if (!state.selection) {
        setStatus('No selection to copy');
        return;
      }
      state.clipboardImage = state.selection.imageData;
      setStatus('Selection copied');
    }

    function cutSelection() {
      if (!state.selection) {
        setStatus('No selection to cut');
        return;
      }
      state.clipboardImage = state.selection.imageData;
      ctx.fillStyle = state.bg;
      ctx.fillRect(state.selection.x, state.selection.y, state.selection.w, state.selection.h);
      pushHistory();
      clearSelection(true);
      setStatus('Selection cut');
    }

    function pasteSelection() {
      if (state.selection && state.selection.imageData) {
        copySelection();
      }

      if (state.clipboardImage) {
        const w = state.clipboardImage.width;
        const h = state.clipboardImage.height;
        state.selection = {
          x: Math.floor((canvas.width - w) / 2),
          y: Math.floor((canvas.height - h) / 2),
          w,
          h,
          imageData: new ImageData(new Uint8ClampedArray(state.clipboardImage.data), w, h)
        };
        renderSelection();
        setStatus('Clipboard pasted as selection');
        return;
      }

      navigator.clipboard.read().then(async (items) => {
        for (const item of items) {
          const type = item.types.find((t) => t.startsWith('image/'));
          if (!type) continue;
          const blob = await item.getType(type);
          const file = new File([blob], `paste.${type.includes('png') ? 'png' : 'jpg'}`, { type });
          await pasteImageAsSelection(await fileToImage(file));
          return;
        }
        setStatus('Clipboard has no image');
      }).catch(() => {
        setStatus('Paste blocked by browser permissions');
      });
    }

    async function pasteImageAsSelection(img) {
      const maxW = Math.min(canvas.width, img.width);
      const maxH = Math.min(canvas.height, img.height);
      const scale = Math.min(maxW / img.width, maxH / img.height, 1);
      const w = Math.max(1, Math.round(img.width * scale));
      const h = Math.max(1, Math.round(img.height * scale));

      const temp = document.createElement('canvas');
      temp.width = w;
      temp.height = h;
      const tctx = temp.getContext('2d');
      tctx.drawImage(img, 0, 0, w, h);
      const data = tctx.getImageData(0, 0, w, h);

      state.clipboardImage = data;
      state.selection = {
        x: Math.floor((canvas.width - w) / 2),
        y: Math.floor((canvas.height - h) / 2),
        w,
        h,
        imageData: data
      };
      renderSelection();
      setStatus('Pasted image as selection');
    }

    function deleteSelection() {
      if (!state.selection) {
        setStatus('No selection to delete');
        return;
      }
      ctx.fillStyle = state.bg;
      ctx.fillRect(state.selection.x, state.selection.y, state.selection.w, state.selection.h);
      pushHistory();
      clearSelection(true);
      setStatus('Selection deleted');
    }

    init();
  </script>
</body>
</html>
